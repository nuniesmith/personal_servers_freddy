# Docker Compose for FREDDY - Personal & Authentication Services  
# Lightweight server handling photos, cloud storage, home automation, and auth

# Named volumes for data/cache/databases only
volumes:
  # Photo Management volumes
  photos_originals:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/photos
  photoprism_storage:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/photoprism/storage
  photoprism_postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/photoprism/postgres

  # Cloud Storage volumes
  nextcloud_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/nextcloud/config
  nextcloud_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/nextcloud/data
  nextcloud_postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/nextcloud/postgres

  # System Services volumes
  homeassistant_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/homeassistant

  # Authentication volumes
  authelia_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/authelia/config
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/authelia/redis
  authelia_postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/authelia/postgres

  # Authentik SSO volumes
  authentik_postgres:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/authentik/postgres
  authentik_redis:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/authentik/redis

  # Reverse Proxy volumes  
  nginx_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/nginx/config

  # Syncthing volumes
  syncthing_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/syncthing/config
  syncthing_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /mnt/1tb/syncthing/data

# Custom networks for service isolation
networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
  database:
    driver: bridge

services:
  # =============================================================================
  # REVERSE PROXY
  # =============================================================================

  # nginx reverse proxy
  nginx:
    image: nginx:latest
    container_name: nginx
    environment:
      - TZ=${TZ:-America/Toronto}
    volumes:
      - ./services/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./services/nginx/conf.d:/etc/nginx/conf.d:ro
      - ./services/nginx/html:/dashboard:ro  # Mount dashboard files
      - /opt/ssl/7gram.xyz:/etc/nginx/ssl:ro  # Mount your certs
    ports:
      - "80:80"
      - "443:443"
    restart: unless-stopped
    networks:
      - frontend
      - backend
    extra_hosts:
      - "sullivan.7gram.xyz:100.73.41.1"  # Sullivan server IP
      - "sullivan:100.73.41.1"            # Short name for nginx configs
      - "freddy.7gram.xyz:100.73.41.1"    # Freddy server IP (self)
      - "freddy:100.73.41.1"              # Short name for nginx configs
      - "oryx:100.73.41.1"                # Oryx server (if exists)
      - "desktop:100.73.41.1"             # Desktop (if exists)
    # Note: No depends_on - nginx should start immediately and proxy to services as they come up
    healthcheck:
      test: ["CMD-SHELL", "curl -kf https://127.0.0.1/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s  # Give nginx time to start HTTPS

  # =============================================================================
  # PHOTO MANAGEMENT
  # =============================================================================

  # photoprism - dedicated photo management app
  photoprism:
    image: photoprism/photoprism:latest
    container_name: photoprism
    environment:
      - PHOTOPRISM_ADMIN_PASSWORD=${PHOTOPRISM_ADMIN_PASSWORD:-pleasechange}
      - PHOTOPRISM_SITE_URL=http://localhost:2342/
      - PHOTOPRISM_DATABASE_DRIVER=postgres
      - PHOTOPRISM_DATABASE_SERVER=photoprism-postgres:5432
      - PHOTOPRISM_DATABASE_NAME=${PHOTOPRISM_DB_NAME:-photoprism}
      - PHOTOPRISM_DATABASE_USER=${PHOTOPRISM_DB_USER:-photoprism}
      - PHOTOPRISM_DATABASE_PASSWORD=${PHOTOPRISM_DB_PASSWORD:-changeme}
      - PHOTOPRISM_UID=${PUID:-1000}
      - PHOTOPRISM_GID=${PGID:-1000}
      - TZ=${TZ:-America/Toronto}
    volumes:
      - /mnt/1tb/photos/originals:/photoprism/originals
      - photoprism_storage:/photoprism/storage
    ports:
      - "2342:2342"
    restart: unless-stopped
    depends_on:
      photoprism-postgres:
        condition: service_healthy
    networks:
      - backend
      - database
    healthcheck:
      test: ["CMD", "photoprism", "status"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # postgres database for photoprism
  photoprism-postgres:
    image: postgres:16-alpine
    container_name: photoprism-postgres
    environment:
      - POSTGRES_DB=${PHOTOPRISM_DB_NAME:-photoprism}
      - POSTGRES_USER=${PHOTOPRISM_DB_USER:-photoprism}
      - POSTGRES_PASSWORD=${PHOTOPRISM_DB_PASSWORD:-changeme}
      - TZ=${TZ:-America/Toronto}
    volumes:
      - photoprism_postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    networks:
      - database
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${PHOTOPRISM_DB_USER:-photoprism}", "-d", "${PHOTOPRISM_DB_NAME:-photoprism}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # =============================================================================
  # CLOUD STORAGE
  # =============================================================================

  # nextcloud - file sharing with postgres db
  nextcloud:
    image: lscr.io/linuxserver/nextcloud:latest
    container_name: nextcloud
    environment:
      - PUID=${PUID:-1000}
      - PGID=${PGID:-1000}
      - TZ=${TZ:-America/Toronto}
      - POSTGRES_HOST=nextcloud-postgres
      - POSTGRES_DB=${NEXTCLOUD_DB_NAME:-nextcloud}
      - POSTGRES_USER=${NEXTCLOUD_DB_USER:-nextcloud}
      - POSTGRES_PASSWORD=${NEXTCLOUD_DB_PASSWORD:-changeme}
    volumes:
      - nextcloud_config:/config
      - nextcloud_data:/data
    ports:
      - "8443:443"
    restart: unless-stopped
    depends_on:
      nextcloud-postgres:
        condition: service_healthy
    networks:
      - backend
      - database
    healthcheck:
      test: ["CMD-SHELL", "curl -fk https://localhost/status.php || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s

  # postgres database for nextcloud
  nextcloud-postgres:
    image: postgres:16-alpine
    container_name: nextcloud-postgres
    environment:
      - POSTGRES_DB=${NEXTCLOUD_DB_NAME:-nextcloud}
      - POSTGRES_USER=${NEXTCLOUD_DB_USER:-nextcloud}
      - POSTGRES_PASSWORD=${NEXTCLOUD_DB_PASSWORD:-changeme}
      - TZ=${TZ:-America/Toronto}
    volumes:
      - nextcloud_postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    networks:
      - database
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${NEXTCLOUD_DB_USER:-nextcloud}", "-d", "${NEXTCLOUD_DB_NAME:-nextcloud}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # =============================================================================
  # SYSTEM SERVICES
  # =============================================================================

  # home assistant (requires host network for device discovery)
  homeassistant:
    image: ghcr.io/home-assistant/home-assistant:stable
    container_name: homeassistant
    privileged: true
    network_mode: host  # Required for device discovery
    environment:
      - TZ=${TZ:-America/Toronto}
    volumes:
      - homeassistant_config:/config
      - /etc/localtime:/etc/localtime:ro
      - /run/dbus:/run/dbus:ro
      - /dev:/dev
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:8123/manifest.json"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # audiobookshelf
  audiobookshelf:
    image: ghcr.io/advplyr/audiobookshelf:latest
    container_name: audiobookshelf
    ports:
      - 13378:80
    volumes:
      - ./services/audiobookshelf/config:/config
      - ./services/audiobookshelf/metadata:/metadata
      - ${MEDIA_PATH_AUDIOBOOKS:-/media/audiobooks}:/audiobooks
    environment:
      - TZ=${TZ:-America/Toronto}
      - PUID=${PUID:-1000}
      - PGID=${PGID:-1000}
    networks:
      - backend
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "wget --spider --quiet http://localhost:80/healthcheck || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # =============================================================================
  # FILE SYNCHRONIZATION
  # =============================================================================

  # syncthing - continuous file synchronization
  syncthing:
    image: lscr.io/linuxserver/syncthing:latest
    container_name: syncthing
    hostname: freddy-syncthing
    environment:
      - PUID=${PUID:-1000}
      - PGID=${PGID:-1000}
      - TZ=${TZ:-America/Toronto}
    volumes:
      - syncthing_config:/config
      - syncthing_data:/data
      # Add additional sync folders as needed
      # - /mnt/1tb/sync:/sync
    ports:
      - "8384:8384"      # Web UI
      - "22000:22000/tcp" # TCP file transfers
      - "22000:22000/udp" # QUIC file transfers  
      - "21027:21027/udp" # Local discovery
    restart: unless-stopped
    networks:
      - backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8384/rest/noauth/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # =============================================================================
  # AUTHENTIK SSO (Single Sign-On)
  # =============================================================================

  # postgres database for authentik
  authentik-postgres:
    image: postgres:16-alpine
    container_name: authentik-postgres
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "authentik"]
      timeout: 20s
      interval: 10s
      retries: 5
    volumes:
      - authentik_postgres:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: ${AUTHENTIK_POSTGRES_PASSWORD}
      POSTGRES_USER: authentik
      POSTGRES_DB: authentik
      TZ: ${TZ:-America/Toronto}
    networks:
      - database

  # redis cache for authentik
  authentik-redis:
    image: redis:alpine
    container_name: authentik-redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      timeout: 20s
      interval: 10s
      retries: 5
    volumes:
      - authentik_redis:/data
    networks:
      - backend

  # authentik server
  authentik-server:
    image: ghcr.io/goauthentik/server:latest
    container_name: authentik-server
    restart: unless-stopped
    command: server
    environment:
      AUTHENTIK_REDIS__HOST: authentik-redis
      AUTHENTIK_POSTGRESQL__HOST: authentik-postgres
      AUTHENTIK_POSTGRESQL__USER: authentik
      AUTHENTIK_POSTGRESQL__NAME: authentik
      AUTHENTIK_POSTGRESQL__PASSWORD: ${AUTHENTIK_POSTGRES_PASSWORD}
      AUTHENTIK_SECRET_KEY: ${AUTHENTIK_SECRET_KEY}
      # Email configuration
      AUTHENTIK_EMAIL__HOST: ${EMAIL_HOST}
      AUTHENTIK_EMAIL__PORT: ${EMAIL_PORT}
      AUTHENTIK_EMAIL__USE_TLS: "true"
      AUTHENTIK_EMAIL__FROM: ${EMAIL_FROM}
      AUTHENTIK_EMAIL__USERNAME: ${EMAIL_USERNAME}
      AUTHENTIK_EMAIL__PASSWORD: ${EMAIL_PASSWORD}
      # Error reporting
      AUTHENTIK_ERROR_REPORTING__ENABLED: ${AUTHENTIK_ERROR_REPORTING__ENABLED:-false}
      TZ: ${TZ:-America/Toronto}
    volumes:
      - ./services/authentik/media:/media
      - ./services/authentik/custom-templates:/templates
    ports:
      - "9000:9000"
      - "9443:9443"
    depends_on:
      - authentik-postgres
      - authentik-redis
    networks:
      - backend
      - database
    healthcheck:
      test: ["CMD-SHELL", "wget --spider --quiet http://localhost:9000/-/health/live/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s

  # authentik worker
  authentik-worker:
    image: ghcr.io/goauthentik/server:latest
    container_name: authentik-worker
    restart: unless-stopped
    command: worker
    user: root
    environment:
      AUTHENTIK_REDIS__HOST: authentik-redis
      AUTHENTIK_POSTGRESQL__HOST: authentik-postgres
      AUTHENTIK_POSTGRESQL__USER: authentik
      AUTHENTIK_POSTGRESQL__NAME: authentik
      AUTHENTIK_POSTGRESQL__PASSWORD: ${AUTHENTIK_POSTGRES_PASSWORD}
      AUTHENTIK_SECRET_KEY: ${AUTHENTIK_SECRET_KEY}
      # Email configuration
      AUTHENTIK_EMAIL__HOST: ${EMAIL_HOST}
      AUTHENTIK_EMAIL__PORT: ${EMAIL_PORT}
      AUTHENTIK_EMAIL__USE_TLS: "true"
      AUTHENTIK_EMAIL__FROM: ${EMAIL_FROM}
      AUTHENTIK_EMAIL__USERNAME: ${EMAIL_USERNAME}
      AUTHENTIK_EMAIL__PASSWORD: ${EMAIL_PASSWORD}
      # Error reporting
      AUTHENTIK_ERROR_REPORTING__ENABLED: ${AUTHENTIK_ERROR_REPORTING__ENABLED:-false}
      TZ: ${TZ:-America/Toronto}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./services/authentik/media:/media
      - ./services/authentik/certs:/certs
      - ./services/authentik/custom-templates:/templates
    depends_on:
      - authentik-postgres
      - authentik-redis
    networks:
      - backend
      - database